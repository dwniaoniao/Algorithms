- 输入：可排序的序列a[0...n-1]
- 输出：升序排序的序列a[0...n-1]

### BubbleSort 冒泡排序
比较表中的相邻元素，如果它们为逆序则交换它们的位置，重复多次以后，最大的元素就“沉到”列表的最后一个位置。第二遍操作将第二大的元素沉下去，持续这样的操作n-1遍以后，完成表的排序。

### SelectionSort 选择排序
扫描整个表找到最小元素，然后和第一个元素交换，将最小元素放到它在有序表的最终位置上。然后从第二个元素开始扫描表，找到最后n-1个元素中的最小元素，再和第二个元素交换位置，把第二小的元素放在它的最终位置上。依次进行n-1遍，列表排序完成。

### QuickSort 快速排序
以表的第一个元素为划分中值对表进行划分，划分完成后，中值左边的元素都小于等于中值，右边的元素都大于等于中值，中值所在的位置就是它最终在有序表中的位置。接下来再对中值左边和右边的元素分别递归进行快速排序。  
划分采用**霍尔算法(HoarePartion)**:  
分别从子表的两端进行扫描，将扫描到的元素与中值比较。从左向右扫描时忽略小于等于中值的元素，直到遇到第一个大于中值的元素才停止；从右向左扫描时忽略大于等于中值的元素，直到遇到第一个小于中值的元素才停止。两次扫描都停止以后，取决与扫描的指针是否相交，会发生2种不同的情况：  
    1. 如果扫描指针i和j不相交，即i < j，简单地交换a[i]和a[j]，再对i加1，对j减1，然后继续开始扫描。  
    1. 如果指针相交，即i > j，把中值和a[j]进行交换，得到该表的一个划分。

### InsertionSort 插入排序
遵循减一技术的思路，假设对较小数组a[0...n-2]排序的问题已经解决，得到一个大小为n-1的有序序列，在这些有序的元素中为a[n-1]找到一个合适的位置，把它插入到这个位置上，就得到问题的解。从右向左扫描这个有序的子序列，直到遇到第一个小于等于a[n-1]的元素，然后把a[n-1]插在该元素的后面。
